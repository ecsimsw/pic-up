# 20231020 RabbitMQ 도입하기

## RestTemplate
기존에는 서버간 비동기 통신에 RestTemplate 을 사용했다.
Album -> Storage 에서 Storage server 가 제대로 파일을 처리하지 못하고 응답하는 경우, 그 재시도나 후처리는 Storage server 가 한다.
그래서 당장은 이벤트를 Storage server 가 제대로 수신하기만 하면 Album server 에선 더 이상 신경 쓸 일이 없다.

문제는 Storage 서버 상태에 있었다.
응답 서버가 down 되면 connection 재시도 정책이 각각의 서버마다 필요했고, connection을 요청하는 쪽에서 재시도 시간 동안 스레드가 물려있다는 문제도 있었다.
또 재시도를 포기한다고 하면 그 이벤트를 어떻게 관리할지 고민이 필요했다.

## Message queue
Message queue 를 도입하게 되었다. Storage server 나 그 외 서버간 통신해야 하는 각각 서버의 HA에 대한 집중을 조금이나마 여유롭게 할 수 있겠다는 생각이었다.
MQ 서버 하나만 확실하게 HA가 보장된다면 설사 각 서버들 중 하나가 잠시 다운 타임이 생겼다가 켜져도 그 때 MQ 에서 처리해야 할 다음 일을 전달하면 그만일 뿐이다.

응답 서버가 잠시 다운되어 있을 때 요청 서버는 기존에는 그 응답 서버의 복구를 기다리거나, 포기한다면 그 이벤트를 어떻게 저장해뒀다가 다시 전송해야 했을지를 고민했다면,
이제는 MQ에 한번 전송해두고 응답 서버가 다시 복구 되었을 때 MQ 에서 이벤트를 전달하면 된다.

마지막으로 MQ 는 fully managed system 들이 선택지가 될 수 있음을 확인했다.
각 모듈별 WAS 의 HA 를 고민하는 것과, Amazon MQ 처럼 사용 시스템의 HA 를 고민하는 것 중에 후자가 더 안전할 것이라 생각했다.
(물론 MQ 의 HA 가 완벽하더라도 각 모듈별 WAS 의 HA 를 완전히 신경쓰지 않아도 된다는 것은 아니다.)

## RabbitMQ

### Process
Producer -> Exchange (Binding rule) -> Queue -> Consumer

### Exchange
메시지를 받고 queue 에 전달한다.
- Direct Exchange : Queue 의 routing key 에 따라 전달된다. 한 개의 queue 가 여러 key 를 갖을 수 있고, 여러 queue 가 같은 키를 갖을 수도 있다.
- Fanout Exchange : Binding 되어 있는 모든 queue 에 전달된다.
- Topic Exchange : routing key 의 패턴을 만족하는 모든 queue 에 전달한다.
- Headers Exchange : 메시지 헤더의 속성에 만족하는 모든 queue 에 전달한다.

### Durability (Queue or Message)
- durable 은 Message 가 queue 에 저장될 때 disk 에 저장되게 하고, transient 는 메모리에 저장되게 한다.

### Round robin dispatch / Fair dispatch
- queue 에서 consumer 에게 메시지를 반드시 하나씩 전달해야 하는 것은 아니다.
- queue 는 dispatch 알고리즘에 따라 번갈아 메시지를 전달하고 consumer 는 이를 메모리에 저장해뒀다가 하나씩 꺼내 처리한다.
- 이 consumer 가 메모리에 쌓아둘 수 있는 메시지 최대 개수를 prefetch 라고 한다.

- 만약 작업의 처리 시간이 길고 불균등이 크다면 최대 처리 가능 개수를 작게하는 것이 좋다. 그 값이 작을 수록 여러 작업자들이 동시 처리에 유리해진다.
- 반대로 작업의 처리 시간이 짧고 균등하다면 최대 처리 가능 개수를 크게 하는 것이 좋다. 작업 스위치가 빠른 상황에선 처리 대기 큐에 쌓여 있는 작업만 많아질 뿐이다.

- Queue 에서 consumer 에게 일을 전달할 때는 기본적으로 Round robin 방식을 사용하지만, prefetch 를 지정하는 것으로 consumer 의 상태와 처리 속도에 따라 다르게 분배할 수도 있다.
- Consumer 는 일 처리가 끝나면 이를 ACK 로 알리는데 최대 처리 가능 수보다 더 많은 일을 dispatch 하지 않는다.

- The default value of prefetch count is 20.

### Options for cost
- Auto delete : Consumer 가 없다면 queue 를 자동 삭제한다.
- Message TTL : 각 메시지에 TTL 를 적용하여 메시지 삭제 기간을 지정 할 수 있다.
- Queue length limit : Messages will be dropped or dead-lettered from the front of the queue to make room for new messages once the limit is reached.
- ACK, Time out : Consumer 는 작업 처리를 마치면 ACK 로 응답한다. Time out 시간 동안 ACK 응답이 없으면 Consumer 가 처리 도중 문제가 생겼다고 생각하고 해당 message 를 다시 Queue 에 삽입한다.

- Message TTL 이 다 지나도 큐에서 Message 가 지워지는 것은 아니다.
- Messages with expired ttl will stay in queue as long as they not reached queue head. Don't worry, they will not be send to consumer, but they will take some resources until they reach head.

### REF
https://medium.com/javarevisited/getting-started-with-rabbitmq-in-spring-boot-6323b9179247
